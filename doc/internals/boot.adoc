
= Boot and init

== Summary

* Reset handler
* Booting up cores
** Architecture dependent codes in `arch/(arch name)/`.
* Init drivers
** In `sys/init.c`.
** Driver codes in and `drivers/*`.
** Device definitions in `boards/(arch name)/(board name)/board.c`.
* Init arguments
** (Accelerator mode only) Copy and setup parameters from host.
* Init idle/main threads
* Switch to main thread
** `sys/thread.c`.

At main thread.

* Init C library
** C library dependent codes in `sys/(libc name)/support.c`.
** Jump to main


== Booting up Cores

An ID of main core is configured by CONFIG_MAIN_CORE.
Maximum number of all cores that include main and all sub cores by CONFIG_NUM_CORES.
Each boards config define how many cores are used by runtime.

This is an example of boot sequence on 3 cores system.

[plantuml]
----
@startuml
participant "Main Core" as Main
participant "Sub Core1" as Sub1
participant "Sub Core2" as Sub2

-> Main : reset
activate Main
activate Sub1
Sub1 -> Sub1 : I am not main, \nwait for wakeup
deactivate Sub1
activate Sub2
Sub2 -> Sub2 : I am not main, \nwait for wakeup
deactivate Sub2

Main -> Sub1 : wakeup(Sub1)
activate Sub1
Main -> Main : wait(Sub1)
deactivate Main
Sub1 -> Main : notify
activate Main

Main -> Sub2 : wakeup(Sub2)
activate Sub2
Main -> Main : wait(Sub2)
deactivate Main
Sub2 -> Main : notify
activate Main

Sub1 -> Sub1 : init_sub_core()
Sub2 -> Sub2 : init_sub_core()
Main -> Main : init_main_core()
@enduml
----


== Unused Cores

This runtime does not manage about unused cores that are not marked as used by the board config.
Unused cores are going to busy loop if all cores run from reset handler (this should be start point of runtime).

=== Case 1

* Number of HW cores: 6
* CONFIG_MAIN_CORE: 0
* CONFIG_NUM_CORES: 4
* board config: use 0, 4

Cores status will be:

* core 0, 4: managed by this runtime
* core 1, 2, 3, 5: behavior is implementation-defined (maybe go to busy loop)


=== Case 2

* Number of HW cores: 4
* CONFIG_MAIN_CORE: 0
* CONFIG_NUM_CORES: 2
* board config: use 0, 1, 2, 3

The main core adds core 0 and 1 to core list and it will succeed, and tries to add core 2 and 3 but it will get failure and some error messages.
It is because number of cores on the runtime cannot exceed the limits CONFIG_NUM_CORES.
Finally, cores status will be:

* core 0, 1: managed by this runtime
* core 2, 3: behavior is implementation-defined (maybe go to busy loop)


== Init drivers

=== HAL

HALs (hardware abstraction layer) are implemented in `drivers/(hw name)/(hal name).c`.
For example `drviers/uart/uart.c` is HAL of UART hardwares.

=== Initialize drivers

The runtime calls init functions that are defined by `define_init_func()` macro at boot time.
This macro lists pointers of init function in the `.initdata` section.
Here is example code of an init function and using macro.

[source,c]
----
static int uart_foo_init(void)
{
	__uart_add_driver(&uart_foo_drv);

	return 0;
}
define_init_func(uart_foo_init);
----

Driver codes need to register their attributes to the runtime.
The runtime will use it to find suitable matching for driver and device pair.

=== Initialize devices

Device parameters and configurations are defined in board dependent codes `boards/(arch name)/(board name)/board.c`.
Typically a board init function registers all devices in the runtime.
The runtime will callback `add()` function if suitable driver is registered.

Here is an example initialize sequence and relationships of driver/board/device.

[plantuml]
----
@startuml
participant "Runtime" as Runtime
participant "Board" as Board
participant "HAL" as HAL
participant "Driver" as Driver
participant "HW" as HW

activate Runtime

Runtime -> Driver : call init
activate Driver
Driver -> HAL : register driver
activate HAL
HAL -> HAL : add driver to list
HAL -> Driver
deactivate HAL
Driver -> Runtime
deactivate Driver

Runtime -> Board : call init
activate Board
Board -> HAL : register device
activate HAL
HAL -> HAL : find suitble driver
HAL -> Driver : callback add()
activate Driver
Driver -> HW : setup registers etc.
activate HW
HW -> Driver
deactivate HW
Driver -> HAL
deactivate Driver
HAL -> Board
deactivate HAL
Board -> Runtime
deactivate Board
@enduml
----

== Init arguments


== Init idle/main threads


== Switch to main thread


== Init C library
