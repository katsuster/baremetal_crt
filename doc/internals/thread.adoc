
= Threads

== Processes

This runtime uses only one process with kernel execution.
Not support fork() and similar features for creating processes.


== Booting up Cores

An ID of main core is configured by CONFIG_MAIN_CORE.
Maximum number of all cores that include main and all sub cores by CONFIG_NUM_CORES.
Each boards config define how many cores are used by runtime.

This is an example of boot sequence on 3 cores system.

[plantuml]
----
@startuml
participant "Main Core" as Main
participant "Sub Core1" as Sub1
participant "Sub Core2" as Sub2

-> Main : reset
activate Main
activate Sub1
Sub1 -> Sub1 : I am not main, \nwait for wakeup
deactivate Sub1
activate Sub2
Sub2 -> Sub2 : I am not main, \nwait for wakeup
deactivate Sub2

Main -> Sub1 : wakeup(Sub1)
activate Sub1
Main -> Main : wait(Sub1)
deactivate Main
Sub1 -> Main : notify
activate Main

Main -> Sub2 : wakeup(Sub2)
activate Sub2
Main -> Main : wait(Sub2)
deactivate Main
Sub2 -> Main : notify
activate Main

Sub1 -> Sub1 : init_sub_core()
Sub2 -> Sub2 : init_sub_core()
Main -> Main : init_main_core()
@enduml
----


== Unused Cores

This runtime does not manage about unused cores that are not marked as used by the board config.
Unused cores are going to busy loop if all cores run from reset handler (this should be start point of runtime).

=== Case 1

* Number of HW cores: 6
* CONFIG_MAIN_CORE: 0
* CONFIG_NUM_CORES: 4
* board config: use 0, 4

Cores status will be:

* core 0, 4: managed by this runtime
* core 1, 2, 3, 5: behavior is implementation-defined (maybe go to busy loop)


=== Case 2

* Number of HW cores: 4
* CONFIG_MAIN_CORE: 0
* CONFIG_NUM_CORES: 2
* board config: use 0, 1, 2, 3

The main core adds core 0 and 1 to core list and it will succeed, and tries to add core 2 and 3 but it will get failure and some error messages.
It is because number of cores on runtime cannot exceed the limits CONFIG_NUM_CORES.
Finally, cores status will be:

* core 0, 1: managed by this runtime
* core 2, 3: behavior is implementation-defined (maybe go to busy loop)


== Main Thread


== Idle Threads



== Create New Threads

[plantuml]
----
@startuml
participant "Parent App" as ParentU
participant "C library" as libc
participant "Runtime (Parent)" as ParentK
participant "Child Idle" as Idle

activate Idle
activate ParentU
Idle -> Idle : wait for interrupt
deactivate Idle

== Create ==

ParentU -> libc : pthread_create()
deactivate ParentU
activate libc
create "Child App" as ChildU
libc -> ChildU : allocate stack, args
libc -> ParentK : sys_clone()
deactivate libc
activate ParentK
create "Runtime (Child)" as ChildK
ParentK -> ChildK : create thread

ParentK -> Idle : send IPI
activate Idle
libc <- ParentK : mret
deactivate ParentK
activate libc
ParentU <- libc : pthread_create()
deactivate libc
activate ParentU
Idle -> Idle : sys_context_switch(to Child)
Idle -> ChildU : mret
deactivate Idle
activate ChildU

== Join ==

ParentU -> libc : pthread_join(Child)
deactivate ParentU
activate libc
libc -> ParentK : sys_futex(wait)
deactivate libc
activate ParentK
ParentK -> ParentK : wait for interrupt
deactivate ParentK

== Exit ==

ChildU -> ChildU : thread main()

ChildU -> ChildU : exit()
ChildU -> ChildK : sys_exit()
deactivate ChildU
activate ChildK
ChildK -> ChildK : sys_futex(wake)
ChildK -> ParentK : send IPI
activate ParentK
ChildK -> ChildK : sys_context_switch(to Idle)
Idle <- ChildK : mret
deactivate ChildK
activate Idle
Idle -> Idle : wait for interrupt
deactivate Idle

ParentK -> ChildK : destroy thread
destroy ChildK
libc <- ParentK : mret
deactivate ParentK
activate libc
libc -> ChildU : free stack, args
destroy ChildU

ParentU <- libc : pthread_join()
deactivate libc
activate ParentU
@enduml
----

